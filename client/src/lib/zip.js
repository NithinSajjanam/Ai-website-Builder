import JSZip from 'jszip';

/**
 * Utility functions for handling ZIP file operations
 */

/**
 * Creates a ZIP file containing the generated website code
 * @param {Object} code - The generated code object
 * @param {string} code.html - HTML content
 * @param {string} code.css - CSS content  
 * @param {string} code.js - JavaScript content
 * @param {string} code.title - Website title
 * @returns {Promise<Blob>} ZIP file as Blob
 */
export const createWebsiteZip = async (code) => {
  try {
    const zip = new JSZip();
    
    // Create the main HTML file
    const htmlContent = `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>${code.title || 'Generated Website'}</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    ${code.html || ''}
    ${code.js ? '<script src="script.js"></script>' : ''}
</body>
</html>`;

    // Add files to the ZIP
    zip.file('index.html', htmlContent);
    zip.file('styles.css', code.css || '');
    
    if (code.js && code.js.trim()) {
      zip.file('script.js', code.js);
    }
    
    // Add a README file
    const readmeContent = `# Generated Website

This website was automatically generated using AI Website Builder.

## Files
- index.html - Main HTML file
- styles.css - Stylesheet
- ${code.js ? 'script.js - JavaScript functionality' : ''}

## Generation Details
- Generated on: ${new Date().toISOString()}
- Title: ${code.title || 'Untitled'}
- Description: AI-generated website

## How to Use
1. Extract all files to a folder
2. Open index.html in a web browser
3. The website is ready to use!

## Notes
- This is an AI-generated website
- You may want to review and customize the code
- Ensure all external resources are properly linked

---
Generated by AI Website Builder
https://github.com/your-username/ai-website-builder
`;

    zip.file('README.md', readmeContent);
    
    // Add a simple package.json for potential deployment
    const packageJson = {
      name: 'generated-website',
      version: '1.0.0',
      description: 'Website generated by AI Website Builder',
      main: 'index.html',
      scripts: {
        'start': 'python -m http.server 8000',
        'serve': 'npx serve .'
      },
      keywords: ['website', 'ai-generated', 'static-site'],
      author: 'AI Website Builder',
      license: 'MIT'
    };
    
    zip.file('package.json', JSON.stringify(packageJson, null, 2));
    
    // Generate the ZIP file
    const zipBlob = await zip.generateAsync({
      type: 'blob',
      compression: 'DEFLATE',
      compressionOptions: {
        level: 6
      }
    });
    
    return zipBlob;
    
  } catch (error) {
    console.error('Error creating ZIP file:', error);
    throw new Error('Failed to create ZIP file');
  }
};

/**
 * Downloads a Blob as a file
 * @param {Blob} blob - The Blob to download
 * @param {string} filename - The name of the file to download
 */
export const downloadBlob = (blob, filename) => {
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  URL.revokeObjectURL(url);
  document.body.removeChild(a);
};

/**
 * Estimates the size of the generated website
 * @param {Object} code - The generated code object
 * @returns {Object} Size information
 */
export const estimateSize = (code) => {
  const htmlSize = new Blob([code.html || '']).size;
  const cssSize = new Blob([code.css || '']).size;
  const jsSize = new Blob([code.js || '']).size;
  const totalSize = htmlSize + cssSize + jsSize;
  
  return {
    html: formatBytes(htmlSize),
    css: formatBytes(cssSize),
    js: formatBytes(jsSize),
    total: formatBytes(totalSize),
    raw: {
      html: htmlSize,
      css: cssSize,
      js: jsSize,
      total: totalSize
    }
  };
};

/**
 * Formats bytes to human-readable format
 * @param {number} bytes - Number of bytes
 * @returns {string} Formatted string
 */
export const formatBytes = (bytes, decimals = 2) => {
  if (bytes === 0) return '0 Bytes';
  
  const k = 1024;
  const dm = decimals < 0 ? 0 : decimals;
  const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];
  
  const i = Math.floor(Math.log(bytes) / Math.log(k));
  
  return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + ' ' + sizes[i];
};

/**
 * Validates generated code structure
 * @param {Object} code - The generated code to validate
 * @returns {Object} Validation result
 */
export const validateCode = (code) => {
  const errors = [];
  const warnings = [];
  
  if (!code.html || code.html.trim().length === 0) {
    errors.push('HTML content is empty');
  }
  
  if (!code.css || code.css.trim().length === 0) {
    warnings.push('CSS content is empty');
  }
  
  // Basic HTML validation
  if (code.html) {
    if (!code.html.includes('<html') && !code.html.includes('<!DOCTYPE')) {
      warnings.push('HTML may not be a complete document');
    }
    
    if (!code.html.includes('<body')) {
      warnings.push('HTML may be missing body content');
    }
  }
  
  // Basic CSS validation
  if (code.css) {
    const ruleCount = (code.css.match(/{/g) || []).length;
    if (ruleCount === 0) {
      warnings.push('CSS contains no style rules');
    }
  }
  
  return {
    isValid: errors.length === 0,
    errors,
    warnings,
    hasContent: !!(code.html && code.html.trim())
  };
};

/**
 * Creates a data URL for the generated website preview
 * @param {Object} code - The generated code
 * @returns {string} Data URL
 */
export const createPreviewDataUrl = (code) => {
  const content = `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Preview - ${code.title || 'Generated Website'}</title>
    <style>${code.css || ''}</style>
</head>
<body>
    ${code.html || ''}
    <script>${code.js || ''}</script>
</body>
</html>`;

  const blob = new Blob([content], { type: 'text/html' });
  return URL.createObjectURL(blob);
};

export default {
  createWebsiteZip,
  downloadBlob,
  estimateSize,
  formatBytes,
  validateCode,
  createPreviewDataUrl
};
